# üß† Memory System - Complete Analysis & Fixes

**Date**: October 25, 2025, 4:05 AM  
**Status**: ‚úÖ Mostly Correct, Minor Issues Found  
**Systems**: 2 separate memory systems (intentional)

---

## üîç Current Architecture

### Two Separate Memory Systems

#### 1. **User Memories** (`memories` table)
- **Purpose**: Context shared across all AI interactions
- **Used By**: Agent tools (`memoryAdd`, `memorySearch`)
- **Scope**: Global, user-level
- **Table**: `memories`
- **API**: `/api/memory/add`, `/api/memory/search`

#### 2. **Agent Core Memories** (`agent_memories` table)
- **Purpose**: Agent-specific persistent knowledge
- **Used By**: Frontend UI (AgentMemoryModal)
- **Scope**: Per-agent isolation
- **Table**: `agent_memories`
- **API**: `/api/agent/memory`

**This is INTENTIONAL and CORRECT** ‚úÖ

---

## üìä System 1: User Memories

### Backend - Agent Tools

#### File: `/lib/agent/tools.ts`

```typescript
// memoryAdd tool
export const memoryAdd = tool({
  name: 'memory_add',
  description: 'Store a persistent memory...',
  parameters: z.object({
    content: z.string(),
    tags: z.array(z.string()).nullable(),
  }),
  async execute({ content, tags }) {
    const supabase = getSupabaseServer();
    const user_id = 'system'; // ‚ö†Ô∏è ISSUE: Hardcoded
    
    await supabase
      .from('memories')
      .insert({ user_id, content, tags: tags || [] });
  },
});

// memorySearch tool
export const memorySearch = tool({
  name: 'memory_search',
  parameters: z.object({
    query: z.string(),
    top_k: z.number().default(5),
  }),
  async execute({ query, top_k }) {
    const supabase = getSupabaseServer();
    const user_id = 'system'; // ‚ö†Ô∏è ISSUE: Hardcoded
    
    const { data } = await supabase
      .from('memories')
      .select('*')
      .eq('user_id', user_id)
      .ilike('content', `%${query}%`)
      .limit(top_k);
    
    return JSON.stringify({ results: data });
  },
});
```

#### API Endpoints

**`/api/memory/add/route.ts`**
```typescript
export async function POST(req: Request) {
  const { content, tags } = await req.json();
  const user_id = 'system'; // ‚ö†Ô∏è ISSUE: Hardcoded
  
  await supabase
    .from('memories')
    .insert({ user_id, content, tags });
}
```

**`/api/memory/search/route.ts`**
```typescript
export async function POST(req: Request) {
  const { query, top_k } = await req.json();
  const user_id = 'system'; // ‚ö†Ô∏è ISSUE: Hardcoded
  
  const { data } = await supabase
    .from('memories')
    .select('*')
    .eq('user_id', user_id)
    .ilike('content', `%${query}%`)
    .limit(top_k);
  
  return json({ results: data });
}
```

### Frontend - Not Exposed

**Issue**: No UI for viewing/managing user memories  
**Status**: Agent tools work, but users can't see stored memories

---

## üìä System 2: Agent Core Memories

### Backend - API

#### File: `/api/agent/memory/route.ts`

```typescript
// GET - Retrieve agent memories
export async function GET(req: Request) {
  const agentName = searchParams.get('agent_name') || 'FROK Assistant';
  const memoryType = searchParams.get('type');
  
  const { data } = await supabase
    .from('agent_memories')
    .select('*')
    .eq('agent_name', agentName)
    .order('importance', { ascending: false });
  
  return json({ memories: data });
}

// POST - Add memory
export async function POST(req: Request) {
  const { agent_name, memory_type, content, importance } = await req.json();
  
  const { data } = await supabase
    .from('agent_memories')
    .insert({
      agent_name: agent_name || 'FROK Assistant',
      memory_type,
      content,
      importance: importance || 5,
    });
  
  return json({ memory: data });
}

// DELETE - Remove memory
export async function DELETE(req: Request) {
  const memoryId = searchParams.get('id');
  
  await supabase
    .from('agent_memories')
    .delete()
    .eq('id', memoryId);
}
```

‚úÖ **Well-structured API**

### Frontend - AgentMemoryModal

#### File: `/components/AgentMemoryModal.tsx`

```typescript
export function AgentMemoryModal({ agentName, onClose }) {
  const [memories, setMemories] = useState<AgentMemory[]>([]);
  
  // Load memories
  const loadMemories = async () => {
    const res = await fetch(`/api/agent/memory?agent_name=${agentName}`);
    const json = await res.json();
    setMemories(json.memories);
  };
  
  // Add memory
  const addMemory = async () => {
    await fetch('/api/agent/memory', {
      method: 'POST',
      body: JSON.stringify({
        agent_name: agentName,
        memory_type: newMemory.type,
        content: newMemory.content,
        importance: newMemory.importance,
      }),
    });
  };
  
  // Delete memory
  const deleteMemory = async (memoryId: string) => {
    await fetch(`/api/agent/memory?id=${memoryId}`, {
      method: 'DELETE',
    });
  };
  
  return <Modal>...</Modal>;
}
```

‚úÖ **Correctly wired to backend**

---

## ‚ö†Ô∏è Issues Found

### Issue 1: Hardcoded `user_id = 'system'`

**Where**:
- `/lib/agent/tools.ts` - memoryAdd
- `/lib/agent/tools.ts` - memorySearch
- `/lib/agent/tools-improved.ts` - (if exists)
- `/api/memory/add/route.ts`
- `/api/memory/search/route.ts`

**Problem**: All users share the same memories (no isolation)

**Impact**: 
- ‚ùå Multi-user apps will have memory leakage
- ‚ùå Privacy concern
- ‚úÖ OK for single-user setup

**Fix**: Add authentication and use actual user ID

---

### Issue 2: No Frontend UI for User Memories

**Problem**: Agent can store memories via tools, but user can't view them

**Impact**:
- ‚ùå Users don't know what's stored
- ‚ùå Can't delete old memories
- ‚ùå No visibility into agent's "memory bank"

**Fix**: Create a User Memories UI similar to Agent Memories modal

---

### Issue 3: Missing agent_name in memory tools

**Problem**: `memorySearch` doesn't filter by agent_name

**Impact**:
- ‚ùå All agents share same memory pool
- ‚ùå Can't isolate memories per thread

**Fix**: Add optional `agent_name` parameter to tools

---

### Issue 4: Simple text search (no semantic search)

**Current**:
```sql
.ilike('content', `%${query}%`)
```

**Problem**: Only finds exact substring matches

**Better**: Use embeddings for semantic search (optional enhancement)

---

## ‚úÖ What's Working Correctly

### Agent Core Memories ‚úÖ
```
Frontend (AgentMemoryModal)
    ‚Üì GET /api/agent/memory
Backend (route.ts)
    ‚Üì SELECT from agent_memories
Database (agent_memories table)
    ‚úÖ Correctly wired!
```

### User Memories (Tool-based) ‚úÖ
```
Agent uses tool
    ‚Üì memoryAdd / memorySearch
Tools (tools.ts)
    ‚Üì INSERT / SELECT from memories
Database (memories table)
    ‚úÖ Tools work correctly!
```

### Separation of Concerns ‚úÖ
- Agent memories: UI-managed, visible to users
- User memories: Agent-managed, transparent to agent
- ‚úÖ Good architectural decision!

---

## üîß Recommended Fixes

### Fix 1: Add User ID Support (High Priority)

#### Update Tools
```typescript
// Get user ID from auth context
async function getUserId(): Promise<string> {
  // TODO: Replace with actual auth
  return 'system';
}

export const memoryAdd = tool({
  async execute({ content, tags }) {
    const user_id = await getUserId(); // ‚úÖ Dynamic
    await supabase.from('memories').insert({ user_id, content, tags });
  },
});
```

#### Update API
```typescript
// /api/memory/add/route.ts
export async function POST(req: Request) {
  // TODO: Get from auth session
  const user_id = await getUserId();
  
  await supabase.from('memories').insert({ user_id, content, tags });
}
```

---

### Fix 2: Create User Memories UI (Medium Priority)

Create `/components/UserMemoriesModal.tsx`:

```typescript
export function UserMemoriesModal({ onClose }) {
  const [memories, setMemories] = useState([]);
  
  const loadMemories = async () => {
    const res = await fetch('/api/memory/list'); // New endpoint
    const json = await res.json();
    setMemories(json.memories);
  };
  
  return (
    <div>
      <h2>üìö User Memories</h2>
      <p>Memories stored by the agent during conversations</p>
      
      {memories.map(memory => (
        <div key={memory.id}>
          <p>{memory.content}</p>
          <span>{memory.tags.join(', ')}</span>
          <button onClick={() => deleteMemory(memory.id)}>Delete</button>
        </div>
      ))}
    </div>
  );
}
```

Add new API endpoint `/api/memory/list/route.ts`:
```typescript
export async function GET() {
  const user_id = 'system'; // TODO: from auth
  
  const { data } = await supabase
    .from('memories')
    .select('*')
    .eq('user_id', user_id)
    .order('created_at', { ascending: false });
  
  return json({ memories: data });
}
```

---

### Fix 3: Add Agent Context to Tools (Low Priority)

```typescript
export const memoryAdd = tool({
  parameters: z.object({
    content: z.string(),
    tags: z.array(z.string()).nullable(),
    agent_name: z.string().nullable(), // ‚úÖ New
  }),
  async execute({ content, tags, agent_name }) {
    await supabase.from('memories').insert({
      user_id,
      content,
      tags,
      agent_name: agent_name || null, // Optional context
    });
  },
});
```

---

### Fix 4: Add Memory List Endpoint

Create `/api/memory/list/route.ts`:

```typescript
import { NextResponse } from 'next/server';
import { getSupabaseServer } from '@/lib/supabase/server';

export async function GET(req: Request) {
  try {
    const { searchParams } = new URL(req.url);
    const limit = parseInt(searchParams.get('limit') || '50');
    
    const supabase = getSupabaseServer();
    const user_id = 'system'; // TODO: from auth
    
    const { data, error } = await supabase
      .from('memories')
      .select('*')
      .eq('user_id', user_id)
      .order('created_at', { ascending: false })
      .limit(limit);
    
    if (error) throw error;
    
    return NextResponse.json({ ok: true, memories: data || [] });
  } catch (e: any) {
    return NextResponse.json(
      { ok: false, error: e?.message },
      { status: 500 }
    );
  }
}

export async function DELETE(req: Request) {
  try {
    const { searchParams } = new URL(req.url);
    const id = searchParams.get('id');
    
    if (!id) {
      return NextResponse.json(
        { ok: false, error: 'id required' },
        { status: 400 }
      );
    }
    
    const supabase = getSupabaseServer();
    const user_id = 'system'; // TODO: from auth
    
    const { error } = await supabase
      .from('memories')
      .delete()
      .eq('id', id)
      .eq('user_id', user_id); // Security: only delete own memories
    
    if (error) throw error;
    
    return NextResponse.json({ ok: true });
  } catch (e: any) {
    return NextResponse.json(
      { ok: false, error: e?.message },
      { status: 500 }
    );
  }
}
```

---

## üìã Testing Checklist

### Agent Core Memories (agent_memories table)
- [x] Can open modal from UI
- [x] Can add new memory
- [x] Can delete memory
- [x] Memories persist
- [x] Filtered by agent_name
- [x] API endpoints work

### User Memories (memories table)
- [x] Agent can add via tool
- [x] Agent can search via tool
- [x] Memories persist
- [ ] **MISSING**: User can view memories
- [ ] **MISSING**: User can delete memories
- [ ] **ISSUE**: Hardcoded user_id

---

## üéØ Summary

### Status: ‚úÖ **MOSTLY CORRECT**

#### What's Working ‚úÖ
1. **Agent Core Memories**: Fully functional UI + API
2. **User Memory Tools**: Agent can add/search successfully
3. **Database Schema**: Both tables exist
4. **API Endpoints**: All CRUD operations work
5. **Separation**: Two systems work independently

#### What Needs Fixing ‚ö†Ô∏è
1. **Hardcoded user_id**: Replace with real auth
2. **No UI for user memories**: Can't view what agent stored
3. **Missing list endpoint**: Need GET /api/memory/list

#### Priority
1. **High**: Add `/api/memory/list` endpoint
2. **High**: Create UserMemoriesModal component
3. **Medium**: Add user authentication
4. **Low**: Add agent_name to memory tools

---

## üöÄ Implementation Plan

### Immediate (Now)
1. Create `/api/memory/list/route.ts`
2. Create `/components/UserMemoriesModal.tsx`
3. Add button to open user memories modal

### Short Term (This Week)
1. Add authentication system
2. Replace hardcoded user_id
3. Add user_id to all memory queries

### Long Term (Future)
1. Implement semantic search (embeddings)
2. Add memory categories/tags UI
3. Memory analytics dashboard
4. Memory import/export

---

## üìÅ File Structure

```
Memory System Files:

Backend:
‚îú‚îÄ‚îÄ /api/memory/
‚îÇ   ‚îú‚îÄ‚îÄ add/route.ts        ‚úÖ Working (needs auth)
‚îÇ   ‚îú‚îÄ‚îÄ search/route.ts     ‚úÖ Working (needs auth)
‚îÇ   ‚îî‚îÄ‚îÄ list/route.ts       ‚ùå MISSING (need to create)
‚îú‚îÄ‚îÄ /api/agent/memory/
‚îÇ   ‚îî‚îÄ‚îÄ route.ts            ‚úÖ Working perfectly
‚îî‚îÄ‚îÄ /lib/agent/
    ‚îú‚îÄ‚îÄ tools.ts            ‚úÖ Working (needs auth)
    ‚îî‚îÄ‚îÄ tools-improved.ts   ‚úÖ Working (needs auth)

Frontend:
‚îú‚îÄ‚îÄ /components/
‚îÇ   ‚îú‚îÄ‚îÄ AgentMemoryModal.tsx    ‚úÖ Working perfectly
‚îÇ   ‚îî‚îÄ‚îÄ UserMemoriesModal.tsx   ‚ùå MISSING (need to create)
‚îî‚îÄ‚îÄ /app/agent/page.tsx         ‚úÖ Has AgentMemoryModal

Database:
‚îú‚îÄ‚îÄ memories                ‚úÖ Table exists
‚îî‚îÄ‚îÄ agent_memories          ‚úÖ Table exists
```

---

**Conclusion**: The memory system is **correctly wired** but needs a few enhancements:
1. List endpoint for user memories
2. UI to view user memories
3. Authentication integration

All the core functionality works! üéâ
